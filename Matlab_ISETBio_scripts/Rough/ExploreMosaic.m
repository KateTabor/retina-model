cm   = theMRGCmosaic.inputConeMosaic;
ecc  = theMRGCmosaic.eccentricityDegs;
sz   = theMRGCmosaic.sizeDegs;
dom  = [ecc(1)+0.5*sz(1)*[-1 1], ecc(2)+0.5*sz(2)*[-1 1]];
ticks = struct('x', ecc(1)+0.5*sz(1)*[-1 -0.5 0 0.5 1], ...
               'y', ecc(2)+0.5*sz(2)*[-1 -0.5 0 0.5 1]);

mcw = mRGCMosaic.sensitivityAtPointOfOverlap;                 % center threshold
msw = theMRGCmosaic.minSurroundWeightForInclusionInComputing; % surround threshold
%% Figure 1
% figure(1); clf;
% cm.visualize('domainVisualizationLimits',dom, ...
%              'domainVisualizationTicks',ticks, ...
%              'plotTitle','Input CONE mosaic (L/M/S)');

%% Figure 2

figure(2); clf;

% % original
% theMRGCmosaic.visualize('minConeWeightVisualized',mcw, ...
%                         'identifyInputCones',false, ...
%                         'identifyPooledCones',false, ...
%                         'domainVisualizationLimits',dom, ...
%                         'domainVisualizationTicks',ticks, ...
%                         'plotTitle',sprintf('mRGC RF centers (min=%.3f)', mcw));

% % cone lattice backdrop
% theMRGCmosaic.visualize('minConeWeightVisualized',mcw, ...
%                         'identifyInputCones',true, ...
%                         'identifyPooledCones',false, ...
%                         'domainVisualizationLimits',dom, ...
%                         'domainVisualizationTicks',ticks);

% Highlight pooled center cones
theMRGCmosaic.visualize('minConeWeightVisualized',mcw, ...
                        'identifyInputCones',true, ...
                        'identifyPooledCones',true, ...
                        'domainVisualizationLimits',dom, ...
                        'domainVisualizationTicks',ticks);